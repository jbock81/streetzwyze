<?php

abstract class EntityManager extends IdeoObject implements QueryTargetI
{

    /**
     *
     * This is an array of callbacks mapped as 'field' => callable
     * They are called to set filters for some items in the filter.
     * Every callable must accept at least one parameter for the filter
     * field value
     *
     * e.g
     * function($filterItem, $filter=array(), $entityManager=null){
     * }
     *
     * @var callable[]
     *
     */
    protected $filterSetters = array();

    /**
     * @var DbTable $_entity_table
     */
    protected $_entity_table;
    protected $_filter = array();
    protected $_filter_where = array();
    protected $_search_where = "";
    protected $_search_term = "";
    protected $_sort_field = null;
    protected $_sort_direction = 'asc';
    protected $SORT_FIELDS = array();

    /**
     * enables entity caching
     * @var bool
     */
    protected $enable_caching = true;

    /**
     *
     * @var array of primary key of the entityTable
     */
    protected $_primary_key;

    /**
     *
     * @var \DbTableWhere
     */
    protected $searchWhere;

    /**
     *
     * @var Entity[] cache for entities.
     */
    protected static $_cached_by_field = array();
    protected static $SORT_DIRECTIONS = array('asc' => 'Ascending', 'desc' => 'Descending');

    /**
     *
     * Static  variable that holds all instances of generated by ::instance() method
     * @var EntityManager[]
     */
    protected static $instances = array();

    /**
     *
     * @var array
     */
    protected $searchParams = array();

    public function __construct($tableClass, $entityClass = null)
    {
        if ($tableClass instanceof DbTable) {
            $this->_entity_table = $tableClass;
        } elseif (class_exists($tableClass)) {
            $this->_entity_table = new $tableClass();
        } else {
            throwException(new Exception("{$tableClass}: does not exist or is not an instance of DbTable"));
        }

        if ($entityClass && class_exists($entityClass)) {
            $this->_entity_table->setRowClass($entityClass);
        }
    }

    /**
     *
     * @param Entity $entity to save
     * @param int|bool $update replace or not
     * @return int insert id or number of rows affected
     */
    public function save(Entity $entity, $update = false)
    {
        try {
            if ($update) {
                return $entity->update($entity->toArray());
            } else {
                return $entity->save();
            }
        } catch (Exception $e) {
            SystemLogger::error($e->getMessage(), PHP_EOL, $e->getTraceAsString());
            return 0;
        }
    }

    public function delete(DbTableRow $entity)
    {
        return $entity->delete();
    }

    /**
     *
     * Returns all entities matching the specified condition
     * @param string $where
     * @param string $order
     * @param int $limit
     * @param int $offset
     * @param string $group_by
     * @return Entity[]
     */
    public function getAll($where = '', $order = '', $limit = 0, $offset = 0, $group_by = null)
    {
        return $this->_entity_table->fetch(null, $where, $order, $limit, $offset, $group_by);
    }

    /**
     * @return DbTable
     */
    public function getEntityTable()
    {
        return $this->_entity_table;
    }

    /**
     *
     * @param array $data
     * @return Entity rowClass
     */
    public function createEntity($data = array())
    {
        $entityClass = $this->getEntityClass();
        $primaryKey = (array)$this->getPrimaryKey();
        return new $entityClass($data[current($primaryKey)], $data, $this->_entity_table);
    }

    public function getEntityClass()
    {
        return $this->_entity_table->getRowClass();
    }

    public function setFilter($filter, $strict = false, $like_for_string = true)
    {
        if (!is_array($filter)) {
            $filter = (array)$filter;
        }

        if ($strict) {
            $fields = $this->getEntityTable()->getFields(true);
            foreach (array_keys($filter) as $k) {
                if (!in_array($k, $fields) && !array_key_exists($k, $this->filterSetters)) {
                    unset($filter[$k]);
                }
            }
        }

        $where = array();

        foreach ($filter as $field => $value) {
            if (array_key_exists($field, $this->filterSetters)) {
                $setter = $this->filterSetters[$field];
                if (!is_callable($setter)) {
                    throw new \RuntimeException("Specified callback for {$field} is not callable");
                }

                $where[$field] = call_user_func($setter, $value, $filter, $this);
            } else if (EntitySearchParam::aClassOf($value)) {
                /* @var $value EntitySearchParam */
                $myWhere = new DbTableWhere();
                $value->addToWhere($myWhere, $value->getField() ?: $field);
                $where[$field] = $myWhere->getWhereString();
            } elseif (is_array($value) && !empty($value)) {
                $whereIn = DbTable::generateInList($value);
                $where[$field] = "`{$field}` IN ({$whereIn})";
            } else {
                if (is_string($value) && $like_for_string) {
                    $where[$field] = DbTableWhere::get()->whereLike($field, $value)
                        ->getWhereString();
                } else {
                    $where[$field] = DbTableWhere::get()->where($field, $value)
                        ->getWhereString();
                }
            }
        }

        $this->_filter = array_merge((array)$this->_filter, $filter);
        $this->_filter_where = array_merge($this->_filter_where, $where);
        return $this;
    }

    public function getFilter()
    {
        return $this->_filter;
    }

    public function getFilterWhere()
    {
        return $this->_filter_where;
    }

    public function getFilterWhereString()
    {
        return count($this->_filter_where) ? join(' AND ', $this->_filter_where) : '';
    }

    public static function sanitize_name($str = '')
    {
        return strtoupper(trim($str));
    }

    /**
     *
     * @param string $fld
     * @param string|int $val
     * @param DbTable $tbl
     * @return string cache key
     *
     */
    private static function _fieldValueCacheRef($fld, $val, $tbl)
    {
        if (!is_numeric($val)) {
            $val = self::sanitize_name($val);
        }

        return "{$fld}_{$val}_{$tbl->getName()}_{$tbl->getRowClass()}";
    }

    /**
     *
     * @param string $order order
     * @param int $limit set to 0 to ignore
     * @param int $offset set to 0 to ignore, can only work when $limit > 0
     * @return Entity[]
     */
    public function getList($order = '', $limit = 0, $offset = 0)
    {
        if (!$order && $order !== null && $this->_sort_field) {
            $order = $this->_sort_field . ' ' . $this->_sort_direction;
        }
        return $this->getAll($this->getFilterWhereString(), $order, $limit, $offset);
    }

    /**
     *
     * Fetches entity with the specified value in the specified field or an alias
     * of @see $this->getEntityWhere() when $value is a DbTableWhere object.
     * @param mixed|DbTableWhere $value
     * @param string $field the field to look in, defaults to Primary Key if not
     *  specified.
     * @param mixed $order the order class.
     * @param bool $forceReload determines if the item should be reloaded or not.
     * @return Entity
     */
    public function getEntity($value, $field = '', $order = null, $forceReload = false)
    {
        if (DbTableWhere::aClassOf($value)) {
            $where = $value;
        } else {
            $where = DbTableWhere::get();
            if (!$field) {
                $fieldTmp = (array)$this->_entity_table->getPrimaryKeyField();
                if (empty($fieldTmp)) {
                    throw new DbTableException("Table {$this->_entity_table->getName()} has no primary keys and no field was specified for getEntity");
                }
                $field = $fieldTmp[0];
            }
            $where->where($field, $value);
        }

        if ($order) {
            $where->setOrderBy($order);
        }

        return $this->getEntityWhere($where, $forceReload);
    }

    /**
     *
     * @param DbTableWhere $where
     * @param bool $forceReload determines if EM should use cache in a
     *  case where an entity is in the cache. If not, the entity will be loaded
     *  from DB, defaults to true for compatibilty reasons.
     * @return Entity
     */
    public function getEntityWhere(DbTableWhere $where, $forceReload = true)
    {
        $hash = $where->setLimitAndOffset(1)
            ->hash();
        $ref = self::_fieldValueCacheRef('__w__', $hash, $this->_entity_table);

        //checked if cached
        if (!$forceReload && $this->enable_caching && array_key_exists($ref, self::$_cached_by_field)) {
            return self::$_cached_by_field[$ref];
        }

        $entities = $this->getEntitiesWhere($where);
        $entity = count($entities) ? current($entities) : null;

        if ($this->enable_caching) {
            self::$_cached_by_field[$ref] = $entity;
        }
        return $entity;
    }

    public function setCaching($caching = true)
    {
        $this->enable_caching = $caching;
        return $this;
    }

    public function setSortField($field = '')
    {
        if (!array_key_exists($field, $sfs = $this->getSortFields())) {
            $field = key($sfs);
        }
        $this->_sort_field = $field;
        return $this;
    }

    public function setSortFields(array $fields)
    {
        $this->SORT_FIELDS = $fields;
        return $this;
    }

    public function setSortDirection($dir = '')
    {
        if (!array_key_exists($dir, self::$SORT_DIRECTIONS)) {
            $dir = key(self::$SORT_DIRECTIONS);
        }
        $this->_sort_direction = $dir;
        return $this;
    }

    public function getSortField()
    {
        return $this->_sort_field;
    }

    public function getSortDirection()
    {
        return $this->_sort_direction;
    }

    public function getSortOrderBy()
    {
        $sortOrder = null;
        if ($this->_sort_field) {
            $sortOrder = $this->_sort_field;
            if ($this->_sort_direction) {
                $sortOrder .= ' ' . $this->_sort_direction;
            }
        }
        return $sortOrder;
    }

    public function getSortFields()
    {
        return $this->SORT_FIELDS;
    }

    public function getSortDirections()
    {
        return self::$SORT_DIRECTIONS;
    }

    public function deleteEntity($id = '', $field = null)
    {
        $entity = $this->getEntity($id, $field);
        return $entity ? $entity->delete() : false;
    }

    public static function getEntityCache()
    {
        return self::$_cached_by_field;
    }

    /**
     *
     * @return int cardinality meeting criteria
     */
    public function getCardinalityByFilter()
    {
        //die($this->getFilterWhereString());
        return $this->getEntityTable()->getCardinality($this->getFilterWhereString());
    }

    /**
     *
     * @return int cardinality meeting criteria
     */
    public function getCardinalityWhere(DbTableWhere $where)
    {
        //die($this->getFilterWhereString());
        return $this->_entity_table->getCardinality($where->getWhereString());
    }

    public function clearFilter()
    {
        $this->_filter = $this->_filter_where = array();
        return $this;
    }

    public function clearAndSetFilter($filter, $strict = false, $like_for_string = true)
    {
        return $this->clearFilter()
            ->setFilter($filter, $strict, $like_for_string);
    }

    public function getArrayOfEntityProperty($property, $where = '', $order = '')
    {
        $fields = $this->getEntityTable()->fetchFieldUsingIDAsKey($property, $property, $where, $order);
        return array_values($fields);
    }

    /**
     * Builds a WHERE clasue for search for a term across one or more fields.
     * It breaks the term by space.
     * @param string $term
     * @param array $fields
     * @return \EntityManager
     */
    public function setSearchTerm($term, array $fields)
    {
        $this->_search_term = $term;
        $terms = array_filter(preg_split('/\s+/', $term), 'strlen');
        if (count($fields) < 1 || count($terms) < 1) {
            return $this;
        }

        $whereArr = array();

        for ($i = 0; $i < count($terms); $i++) {
            $termDbLike = DbTable::escapeString($terms[$i]);
            $whereTerm = array();
            foreach ($fields as $fld) {
                $whereTerm[] = $fld . " LIKE '%{$termDbLike}%'";
            }

            $whereArr[] = '(' . join(' OR ', $whereTerm) . ')';
        }

        $where = join(' AND ', $whereArr);
        $this->_search_where = $where;

        return $this;
    }

    public function getSearchWhere()
    {
        return $this->_search_where;
    }

    /**
     * @deprecated since version 2.0.dev
     * @param string $order
     * @param int $limit
     * @param int $offset
     * @return Entity[]
     */
    public function getSearchResult($order = '', $limit = '', $offset = '')
    {
        $where = $this->getSearchWhere();
        return $this->_entity_table->fetch(null, $where, $order, $limit, $offset);
    }

    public function saveMultiple(array $entities, $is_update = false, $additionalProperties = array())
    {

        return DbTable::getDB()
            ->doInTransactionOrRun(function () use ($entities, $is_update, $additionalProperties) {
                foreach ($entities as $entity) {
                    if (is_object($entity) && is_a($entity, DbTableRow::getClass())) {
                        $entity->setRowData($additionalProperties);
                    } elseif (is_array($entity)) {
                        $entity = $this->createEntity(array_merge($entity, $additionalProperties));
                    } else {
                        throw new WrongEntityTypeException("The variable supplied is neither a DbTableRow nor an array");
                    }

                    $this->save($entity, $is_update);
                }

                return true;
            });
    }

    public function getPrimaryKey()
    {
        if (!$this->_primary_key) {
            $this->_primary_key = $this->getEntityTable()->getPrimaryKeyField();
        }
        return $this->_primary_key;
    }

    public static function getLimitOffsetString($limit = 0, $offset = 0)
    {
        $string = "";
        $limit = (int)$limit;
        $offset = (int)$offset;
        if ($limit) {
            $string .= " LIMIT ";
            if ($offset) {
                $string .= $offset . ", ";
            }
            $string .= $limit;
        }
        return $string;
    }

    public static function appendWhereOrderLimitToSql($sql, $where = '', $order = '', $limit = 0, $offset = 0)
    {
        if ($where) {
            $sql .= " WHERE {$where}";
        }

        if ($order) {
            $sql .= " ORDER BY {$order}";
        }

        $limitStr = self::getLimitOffsetString($limit, $offset);
        if ($limitStr) {
            $sql .= $limitStr;
        }

        return $sql;
    }

    /**
     *
     * Returns entities with the specified ID, in the order specified.
     * @param array $ids a list of IDs
     * @param string $field the primary key field or search  field
     * @param bool $indexByField wheteher the resulting array should be indexed by the ID or not
     * @return Entity[]
     */
    public function getEntities($ids, $field = null, $indexByField = true)
    {
        $ids = (array)$ids;

        $entities = [];
        $entitiesById = [];

        if (!$field) {
            $field = $this->getPrimaryKey()[0];
        }

        //retrieve entities from Repo
        $entitiesRs = $this->where()
            ->whereInArray($field, $ids)
            ->results();

        //group entities by ID
        foreach ($entitiesRs as $entity) {
            $entitiesById[$entity->$field] = $entity;
        }

        //organize in the order specified.
        foreach ($ids as $id) {
            if (($entity = $entitiesById[$id])) {
                if ($indexByField) {
                    $entities[$id] = $entity;
                } else {
                    $entities[] = $entity;
                }
            }
        }

        return $entities;
    }

    /**
     *
     * @param DbTableWhere $dbWhere
     * @return Entity[]
     */
    public function getEntitiesWhere(DbTableWhere $dbWhere)
    {
        return $this->getEntityTable()
            ->fetch(null, $dbWhere->getWhereString(), $dbWhere->getOrderBy(), $dbWhere->getLimit(), $dbWhere->getOffset(), $dbWhere->getGroupBy());
    }

    /**
     *
     * This is a somewhat Singleton method for all entity managers, it is not compulsory,
     * just makes instantiation faster.
     *
     * @return static
     *
     */
    public static function instance()
    {
        $instanceKey = get_called_class();

        if (!isset(self::$instances[$instanceKey])) {
            self::$instances[$instanceKey] = new $instanceKey();
        }
        return self::$instances[$instanceKey];
    }

    /**
     *
     * @return DbTable
     */
    static public function table()
    {
        return static::instance()->_entity_table;
    }

    protected function _setSearchParam($param, $key = null, $having = false)
    {
        $paramValue = $key === null ? $this->searchParams[$param] : $this->searchParams[$key];
        if (!is_null($paramValue)) {
            if (!$this->searchWhere) {
                $this->searchWhere = new DbTableWhere();
            }
            /* @var $paramValue EntitySearchParam */
            if (is_object($paramValue) && is_a($paramValue, EntitySearchParam::getClass())) {
                $paramValue->addToWhere($this->searchWhere, $param, $having);
            } elseif (is_array($paramValue)) {
                if ($having) {
                    $this->searchWhere->havingInArray($param, $paramValue);
                } else {
                    $this->searchWhere->whereInArray($param, $paramValue);
                }
            } else {
                if ($having) {
                    $this->searchWhere->having($param, $paramValue);
                } else {
                    $this->searchWhere->where($param, $paramValue);
                }
            }
        }
        return $this;
    }

    public function setSearchParams($searchParam)
    {
        $this->searchParams = $searchParam;
        return $this;
    }

    public static function debug_dump_instances()
    {
        var_dump(self::$instances);
    }

    /**
     *
     * @param array $assoc e.g. arrray('id'=> 'name')
     * @param DbTableWhere $where
     * @return array Description
     *
     */
    public function getPropertyAssoc(array $assoc, $where)
    {
        list($id, $field) = each($assoc);
        return $this->_entity_table->fetchFieldUsingIDAsKey($field, $id, $where->getWhereString(), $where->getOrderBy(), $where->getLimit(), $where->getOffset(), $where->getGroupBy());
    }

    /**
     * Delete a multivalued attribute, must append name of the parent class at the end.
     * @param mixed $id of the MVA
     * @param mixed $parent_object_id reference column of the parent class.
     * @param string name of parent class $parentEntityClass
     * @return int 1 if deleted, 0 other wise
     */
    public function deleteMVAProperty($id, $parent_object_id, $parentEntityClass = null)
    {
        $reference = $this->getParentReference($parentEntityClass);
        $primary_key = $this->getPrimaryKey();
        $where = DbTableWhere::get()
            ->where($reference, $parent_object_id)
            ->where($primary_key[0], $id);
        return $this->getEntityTable()->delete($where->getWhereString(), 1);
    }

    /**
     *
     * Insert or Update Child entities
     * @param array $entitiesData a hash map of id=>mva for the object, when the array is
     * numerically indexed, as in just plain 0...count-1, then they are assumed to be
     * new set of objects excpet the primary key fields are also set in each entity data
     * if the objects are associative, then a test is run to see if the entity has just one primary key field
     * if so, the keys of the associative array are used as primary keys, if an existing entity is found,
     * it is update, if not a new entity is created and saved.
     * @param mixed $refObjectId the foreign key, which is primary key of referenced object [parent],
     * @param bool $forceInsert set to true to ensure that system always inserts the MVAs
     * @param string $parentEntityClass class name of the parent entity.
     * @return int, the number of successfully saved children
     * @deprecated since version 2.0.dev
     *
     */
    public function saveMVAForObject($entitiesData, $refObjectId, $forceInsert = false, $parentEntityClass = null)
    {
        $reference = $this->getParentReference($parentEntityClass);
        $primaryKeys = $this->getPrimaryKey();
        $successful = 0;
        $arrayIsAssoc = array_is_assoc($entitiesData);
        $db = DbTable::getDB();

        foreach ($entitiesData as $key => $entityData) {
            //$entityPk = $entityData[$primaryKeys[0]];
            $pkFields = array();
            copyElementsAtKey($primaryKeys, $entityData, $pkFields, true);

            //if we are forcing insert, then no need to search 
            //for an existing entity as it will be overwritten
            if (!$forceInsert) {
                $searchWhere = DbTableWhere::get();
                if (count($pkFields) === count($primaryKeys)) {
                    foreach ($pkFields as $pkField => $pkFieldVal) {
                        $searchWhere->where($pkField, $pkFieldVal);
                    }
                } elseif ($arrayIsAssoc && count($primaryKeys) === 1) {
                    $searchWhere->where($primaryKeys[0], $key);
                } else {
                    //we are not searching as we could not find anuy primary keys
                    $searchWhere = null;
                }

                $entity = null;
                if ($searchWhere) {
                    $searchWhere->where($reference, $refObjectId);
                    if (($entity = $this->getEntityWhere($searchWhere))) {
                        if ($entity->update($entityData)) {
                            $successful++;
                        }
                    } else {
                        SystemLogger::info("Could not find entity using search: ", $searchWhere->getWhereString());
                    }
                }
            }

            //this is a new data.
            if (!$entity) {
                //ensure new entity references parent
                $entityData[$reference] = $refObjectId;
                if ($this->createEntity($entityData)->save($forceInsert)) {
                    $successful++;
                } elseif ($db->error) {
                    SystemLogger::warn("Failed to insert MVA, error: {$db->error}");
                }
            }
        }

        return $successful;
    }

    public function getParentReference($parentEntityClass)
    {
        return Entity::getFkReference($this->getEntityClass(), $parentEntityClass);
    }

    public static function find($id, $field = 'id', $order = null, $reload = false)
    {
        return static::instance()
            ->getEntity($id, $field, $order, $reload);
    }

    protected function addFilterWhere($key, $where)
    {
        $this->_filter_where[$key] = (string)$where;
        return $this;
    }

    public static function dbTable()
    {
        return static::instance()->getEntityTable();
    }

    public function results(\DbTableWhere $where)
    {
        return $this->getEntitiesWhere($where);
    }

    public function resultsCount(\DbTableWhere $where)
    {
        return $this->getCardinalityWhere($where);
    }

    public function where($field = null, $value = null, $op = '=')
    {
        $where = new DbTableWhere($this);
        if ($field !== null) {
            $where->op($field, $value, $op);
        }
        return $where;
    }

    /**
     * Sets the filter callback to generate condition for a single field
     * @param string $field
     * @param callable $callback
     * @return \EntityManager
     */
    public function setFilterSetter($field, callable $callback)
    {
        $this->filterSetters[$field] = $callback;
        return $this;
    }

    /**
     * Sets the filter callbacks that should be used for fields
     * @param callable[] $filterSetters field=>callback map.
     * @return \EntityManager
     */
    public function setFilterSetters(array $filterSetters, $clearPrevious = false)
    {
        $this->filterSetters = $clearPrevious ? $filterSetters : array_merge($this->filterSetters, $filterSetters);
        return $this;
    }

}

class WrongEntityTypeException extends Exception
{

}
